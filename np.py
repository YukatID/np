NumPy
Задание 1
1. Импортируйте библиотеку Numpy и дайте ей псевдоним np. Создать одномерный массив Numpy под названием a из 12 последовательных целых чисел чисел от 12 до 24 не включительно Создать 5 двумерных массивов разной формы из массива a. Не использовать в аргументах метода reshape число -1. Создать 5 двумерных массивов разной формы из массива a. Использовать в аргументах метода reshape число -1 (в трех примерах - для обозначения числа столбцов, в двух - для строк). Можно ли массив Numpy, состоящий из одного столбца и 12 строк, назвать одномерным?

import numpy as np
a = np.arange(12, 24)
print(a)
[12 13 14 15 16 17 18 19 20 21 22 23]
a.reshape(3, 4)
array([[12, 13, 14, 15],
       [16, 17, 18, 19],
       [20, 21, 22, 23]])
a.reshape(4, 3)
array([[12, 13, 14],
       [15, 16, 17],
       [18, 19, 20],
       [21, 22, 23]])
a.reshape(2, 6)
array([[12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])
a.reshape(6, 2)
array([[12, 13],
       [14, 15],
       [16, 17],
       [18, 19],
       [20, 21],
       [22, 23]])
a.resize(12, 1)
print(a)
[[12]
 [13]
 [14]
 [15]
 [16]
 [17]
 [18]
 [19]
 [20]
 [21]
 [22]
 [23]]
a.reshape(-1, 3)
array([[12, 13, 14],
       [15, 16, 17],
       [18, 19, 20],
       [21, 22, 23]])
np.reshape(a, (-1, 6))
array([[12, 13, 14, 15, 16, 17],
       [18, 19, 20, 21, 22, 23]])
np.reshape(a, (-1, 2))
array([[12, 13],
       [14, 15],
       [16, 17],
       [18, 19],
       [20, 21],
       [22, 23]])
a.reshape(4, -1)
array([[12, 13, 14],
       [15, 16, 17],
       [18, 19, 20],
       [21, 22, 23]])
a.reshape(12, -1)
array([[12],
       [13],
       [14],
       [15],
       [16],
       [17],
       [18],
       [19],
       [20],
       [21],
       [22],
       [23]])
Можно ли массив Numpy, состоящий из одного столбца и 12 строк, назвать одномерным?
Нет.

a.ndim
2
2. Создать массив из 3 строк и 4 столбцов, состоящий из случайных чисел с плавающей запятой из нормального распределения со средним, равным 0 и среднеквадратичным отклонением, равным 1.0.
Получить из этого массива одномерный массив с таким же атрибутом size, как и исходный массив.

a = np.random.randn(3, 4)
print(a)
[[ 0.23904365 -1.34354256  1.94486023  1.29651318]
 [ 0.05608104 -1.60806859  0.47568392  1.53362499]
 [ 0.23813328  0.87463064  0.26511648 -0.49936174]]
b = a.flatten()
print(b)
[ 0.23904365 -1.34354256  1.94486023  1.29651318  0.05608104 -1.60806859
  0.47568392  1.53362499  0.23813328  0.87463064  0.26511648 -0.49936174]
a.size == b.size
True
3. Создать массив a, состоящий из целых чисел, убывающих от 20 до 0 невключительно с интервалом 2.
Создать массив b, состоящий из 1 строки и 10 столбцов: целых чисел, убывающих от 20 до 1 невключительно с интервалом 2.
В чем разница между массивами a и b?

a = np.arange(20, 0, -2)
print(a)
[20 18 16 14 12 10  8  6  4  2]
b = np.arange(20, 1, -2)
print(b)
[20 18 16 14 12 10  8  6  4  2]
Никакой разницы. В обоих случаях получаются одинаковые массивы

np.array_equal(a, b)
True
4. Вертикально соединить массивы a и b. a - двумерный массив из нулей, число строк которого больше 1 и на 1 меньше, чем число строк двумерного массива b, состоящего из единиц. Итоговый массив v должен иметь атрибут size, равный 10.

a = np.zeros((3, 2))
b = np.ones((2, 2))
print('Массив a ', a, sep='\n')
print('Массив b ', b, sep='\n')
Массив a
[[0. 0.]
 [0. 0.]
 [0. 0.]]
Массив b
[[1. 1.]
 [1. 1.]]
v = np.concatenate((a, b), axis = 0)
print(v)
[[0. 0.]
 [0. 0.]
 [0. 0.]
 [1. 1.]
 [1. 1.]]
v.size
10
5. Создать одномерный массив а, состоящий из последовательности целых чисел от 0 до 12. Поменять форму этого массива, чтобы получилась матрица A (двумерный массив Numpy), состоящая из 4 строк и 3 столбцов. Получить матрицу At путем транспонирования матрицы A. Получить матрицу B, умножив матрицу A на матрицу At с помощью матричного умножения. Какой размер имеет матрица B? Получится ли вычислить обратную матрицу для матрицы B и почему?

a = np.arange(0, 12)
print(a)
[ 0  1  2  3  4  5  6  7  8  9 10 11]
A = a.reshape(4, 3)
print(A)
[[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
At = A.transpose()
print(At)
[[ 0  3  6  9]
 [ 1  4  7 10]
 [ 2  5  8 11]]
B = np.dot(A, At)
print(B)
[[  5  14  23  32]
 [ 14  50  86 122]
 [ 23  86 149 212]
 [ 32 122 212 302]]
При умножении матриц число строк итоговой матрицы (B) равно число строк первой матрицы (A), а число столбцов - второй матрицы (At).

B.size
16
Вычислить обратную матрицу для B невозможно, т.к. определитель матрицы B равен 0.

np.linalg.det(B)
0.0
6. Инициализируйте генератор случайных числе с помощью объекта seed, равного 42. Создайте одномерный массив c, составленный из последовательности 16-ти случайных равномерно распределенных целых чисел от 0 до 16 невключительно. Поменяйте его форму так, чтобы получилась квадратная матрица C. Получите матрицу D, поэлементно прибавив матрицу B из предыдущего вопроса к матрице C, умноженной на 10. Вычислите определитель, ранг и обратную матрицу D_inv для D.

np.random.seed(42)
a = np.arange(0, 16)
print(a)
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15]
np.sqrt(a.size)
4.0
C = a.reshape((4, 4))
print(C)
[[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]
 [12 13 14 15]]
print(B)
[[  5  14  23  32]
 [ 14  50  86 122]
 [ 23  86 149 212]
 [ 32 122 212 302]]
C.shape == B.shape
True
D = 10 * C + B
print(D)
[[  5  24  43  62]
 [ 54 100 146 192]
 [103 176 249 322]
 [152 252 352 452]]
np.linalg.det(D)
-7.685903354004529e-25
D_inv = np.linalg.inv(D)
print(D_inv)
[[ 1.10382344e+13  5.26315789e-02 -3.31147031e+13  2.20764688e+13]
 [-8.46264636e+13  9.38249922e+13  6.62294063e+13 -7.54279349e+13]
 [ 1.36138224e+14 -1.87649984e+14 -3.31147031e+13  8.46264636e+13]
 [-6.25499948e+13  9.38249922e+13  0.00000000e+00 -3.12749974e+13]]
7. Приравняйте к нулю отрицательные числа в матрице D_inv, а положительные - к единице. Убедитесь, что в матрице D_inv остались только нули и единицы. С помощью функции numpy.where, используя матрицу D_inv в качестве маски, а матрицы B и C - в качестве источников данных, получите матрицу E размером 4x4. Элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 1, должны быть равны соответствующему элементу матрицы B, а элементы матрицы E, для которых соответствующий элемент матрицы D_inv равен 0, должны быть равны соответствующему элементу матрицы C.

mask_positive = D_inv > 0
mask_negative = D_inv < 0
D_inv[mask_positive] = 1
D_inv[mask_negative] = 0
print(D_inv)
[[1. 1. 0. 1.]
 [0. 1. 1. 0.]
 [1. 0. 0. 1.]
 [0. 1. 0. 0.]]
E = np.where(D_inv, B, C)
print(E)
[[  5  14   2  32]
 [  4  50  86   7]
 [ 23   9  10 212]
 [ 12 122  14  15]]
Задание 2
Создайте массив Numpy под названием a размером 5x2, то есть состоящий из 5 строк и 2 столбцов. Первый столбец должен содержать числа 1, 2, 3, 3, 1, а второй - числа 6, 8, 11, 10, 7. Будем считать, что каждый столбец - это признак, а строка - наблюдение. Затем найдите среднее значение по каждому признаку, используя метод mean массива Numpy. Результат запишите в массив mean_a, в нем должно быть 2 элемента.

a = np.array(
    [[1, 2, 3, 3, 1],
    [6, 8, 11, 10, 7]]
).transpose()
print(a)
[[ 1  6]
 [ 2  8]
 [ 3 11]
 [ 3 10]
 [ 1  7]]
mean_a = np.mean(a, axis = 0)
print(mean_a)
[2.  8.4]
Задание 3
Вычислите массив a_centered, отняв от значений массива а средние значения соответствующих признаков, содержащиеся в массиве mean_a. Вычисление должно производиться в одно действие. Получившийся массив должен иметь размер 5x2.

a_centered = a - mean_a
print(a_centered)
[[-1.  -2.4]
 [ 0.  -0.4]
 [ 1.   2.6]
 [ 1.   1.6]
 [-1.  -1.4]]
Задание 4
Найдите скалярное произведение столбцов массива a_centered. В результате должна получиться величина a_centered_sp. Затем поделите a_centered_sp на N-1, где N - число наблюдений.

a_centered_sp = a_centered.T[0] @ a_centered.T[1]
print(a_centered_sp)
8.0
a_centered_sp / (a_centered.shape[0] - 1)
2.0
Задание 5**
Число, которое мы получили в конце задания 3 является ковариацией двух признаков, содержащихся в массиве а. В задании 4 мы делили сумму произведений центрированных признаков на N-1, а не на N, поэтому полученная нами величина является несмещенной оценкой ковариации. В этом задании проверьте получившееся число, вычислив ковариацию еще одним способом - с помощью функции np.cov. В качестве аргумента m функция np.cov должна принимать транспонированный массив a. В получившейся ковариационной матрице (массив Numpy размером 2x2) искомое значение ковариации будет равно элементу в строке с индексом 0 и столбце с индексом 1.

Подробнее узнать о ковариации можно здесь: Ссылка

np.cov(a.T)[0, 1]
2.0
Pandas
Задание 1
A. Импортируйте библиотеку Pandas и дайте ей псевдоним pd.

import pandas as pd
B. Создайте датафрейм authors со столбцами author_id и author_name, в которых соответственно содержатся данные: [1, 2, 3] и ['Тургенев', 'Чехов', 'Островский'].

authors = pd.DataFrame({'author_id':[1, 2, 3],
                        'author_name':['Тургенев', 'Чехов', 'Островский']},
                       columns=['author_id', 'author_name'])
print(authors)
   author_id author_name
0          1    Тургенев
1          2       Чехов
2          3  Островский
C. Затем создайте датафрейм book cо столбцами author_id, book_title и price,в которых соответственно содержатся данные:
[1, 1, 1, 2, 2, 3, 3], ['Отцы и дети', 'Рудин', 'Дворянское гнездо', 'Толстый и тонкий', 'Дама с собачкой', 'Гроза', 'Таланты и поклонники'], [450, 300, 350, 500, 450, 370, 290].

book = pd.DataFrame({'author_id':[1, 1, 1, 2, 2, 3, 3],
                     'book_title':['Отцы и дети', 'Рудин', 'Дворянское гнездо', 'Толстый и тонкий', 'Дама с собачкой', 'Гроза', 'Таланты и поклонники'],
                     'price':[450, 300, 350, 500, 450, 370, 290]},
                    columns=['author_id', 'book_title', 'price'])
print(book)
   author_id            book_title  price
0          1           Отцы и дети    450
1          1                 Рудин    300
2          1     Дворянское гнездо    350
3          2      Толстый и тонкий    500
4          2       Дама с собачкой    450
5          3                 Гроза    370
6          3  Таланты и поклонники    290
Задание 2
Получите датафрейм authors_price, соединив датафреймы authors и books по полю author_id.

authors_price = pd.merge(authors, book, on = 'author_id', how = 'outer')
print(authors_price)
   author_id author_name            book_title  price
0          1    Тургенев           Отцы и дети    450
1          1    Тургенев                 Рудин    300
2          1    Тургенев     Дворянское гнездо    350
3          2       Чехов      Толстый и тонкий    500
4          2       Чехов       Дама с собачкой    450
5          3  Островский                 Гроза    370
6          3  Островский  Таланты и поклонники    290
Задание 3
Создайте датафрейм top5, в котором содержатся строки из authors_price с пятью самыми дорогими книгами.

top5 = authors_price.nlargest(5, 'price')
print(top5)
   author_id author_name         book_title  price
3          2       Чехов   Толстый и тонкий    500
0          1    Тургенев        Отцы и дети    450
4          2       Чехов    Дама с собачкой    450
5          3  Островский              Гроза    370
2          1    Тургенев  Дворянское гнездо    350
Задание 4
A. Создайте датафрейм authors_stat на основе информации из authors_price.

authors_stat = authors_price['author_name'].value_counts()
print(authors_stat)
Тургенев      3
Островский    2
Чехов         2
Name: author_name, dtype: int64
B. В датафрейме authors_stat должны быть четыре столбца: author_name, min_price, max_price и mean_price, в которых должны содержаться соответственно имя автора, минимальная, максимальная и средняя цена на книги этого автора.

authors_stat = authors_price.groupby('author_name').agg({'price':['min', 'max', 'mean']})
authors_stat = authors_stat.rename(columns={'min':'min_price', 'max':'max_price', 'mean':'mean_price'})
print(authors_stat)
                price
            min_price max_price  mean_price
author_name
Островский        290       370  330.000000
Тургенев          300       450  366.666667
Чехов             450       500  475.000000
Задание 5
Создайте новый столбец в датафрейме authors_price под названием cover, в нем будут располагаться данные о том, какая обложка у данной книги - твердая или мягкая.
В этот столбец поместите данные из следующего списка: ['твердая', 'мягкая', 'мягкая', 'твердая', 'твердая', 'мягкая', 'мягкая'].
Просмотрите документацию по функции pd.pivot_table с помощью вопросительного знака.
Для каждого автора посчитайте суммарную стоимость книг в твердой и мягкой обложке.Используйте для этого функцию pd.pivot_table. При этом столбцы должны называться "твердая" и "мягкая",а индексами должны быть фамилии авторов. Пропущенные значения стоимостей заполните нулями,при необходимости загрузите библиотеку Numpy.
Назовите полученный датасет book_info и сохраните его в формат pickle под названием "book_info.pkl".Затем загрузите из этого файла датафрейм и назовите его book_info2.Удостоверьтесь, что датафреймы book_info и book_info2 идентичны

authors_price['cover'] = ['твердая', 'мягкая', 'мягкая', 'твердая', 'твердая', 'мягкая', 'мягкая']
print(authors_price)
   author_id author_name            book_title  price    cover
0          1    Тургенев           Отцы и дети    450  твердая
1          1    Тургенев                 Рудин    300   мягкая
2          1    Тургенев     Дворянское гнездо    350   мягкая
3          2       Чехов      Толстый и тонкий    500  твердая
4          2       Чехов       Дама с собачкой    450  твердая
5          3  Островский                 Гроза    370   мягкая
6          3  Островский  Таланты и поклонники    290   мягкая
book_info = pd.pivot_table(authors_price, values='price', index=['author_name'], columns=['cover'], aggfunc=np.sum)
book_info['мягкая'] = book_info['мягкая'].fillna(0)
book_info['твердая'] = book_info['твердая'].fillna(0)
print(book_info)
cover        мягкая  твердая
author_name
Островский    660.0      0.0
Тургенев      650.0    450.0
Чехов           0.0    950.0
book_info.to_pickle('book_info.pkl')
book_info2 = pd.read_pickle('book_info.pkl')
book_info.equals(book_info2)
True